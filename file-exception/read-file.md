# ফাইল পড়া

আগের চ্যাপ্টারে আমরা দেখেছি কিভাবে পাইথনে ফাইল খুলতে হয় এবং বন্ধ করতে হয়। এই চ্যাপ্টারে দেখবো কিভাবে ফাইলে খুলে সেই ফাইল থেকে বিভিন্নভাবে কন্টেন্ট পড়া যায়। একটি ফাইল খুলে সেই ফাইলের সব কন্টেন্ট পড়ে স্ক্রিনে প্রিন্ট করার একটি প্রোগ্রাম দেখি -

```python
file_to_work = open("Test.txt", "r")
content = file_to_work.read()

print(content)

file_to_work.close()
```

আউটপুট,

```python
Hello World!!!
This is second line in the file.

This is third one.
```

উপরের প্রোগ্রামের Test.txt ফাইলে তিনটি আলাদা আলাদা লাইনে নিচের কন্টেন্ট ছিলঃ

Hello World!!!  
This is second line in the file.

This is third one.

প্রথমেই ওপেন ফাংশন ব্যবহার করে এবং ফাইলের পাথ ডিফাইন করে দিয়ে একটি ফাইল অবজেক্ট পেয়েছি `file_to_work` নামের। এরপর এই অবেজক্টের মেথড `read` ব্যবহার করে পুরো ফাইলে থাকা কন্টেন্ট পড়ে `content` ভ্যারিয়েবলে জমা করেছি। অতঃপর, একটি প্রিন্ট স্টেটমেন্ট ব্যবহার করে সেই কন্টেন্ট স্ক্রিনে প্রিন্ট করেছি। আর কাজ শেষে, ফাইল অবজেক্ট এর `close` মেথড ব্যবহার করে ফাইলকে ক্লোজ করেছি।

এভাবে পুরো কন্টেন্ট একসাথে না পড়ে বাইট হিসেবেও পড়া যায়। `read` মেথডের আর্গুমেন্ট হিসেবে কত বাইট পড়তে চাই সেটা পাঠিয়ে দেয়া যায়। উপরের প্রোগ্রামের একটু মডিফায়েড ভার্সন দেখি -

```python
file_to_work = open("Test.txt", "r")

just_one_character = file_to_work.read(1)
print(just_one_character)

remaining_four_characters = file_to_work.read(4)
print(remaining_four_characters)

rest_of_the_file = file_to_work.read()
print(rest_of_the_file)

file_to_work.close()
```

আউটপুট,

```python
H
ello
 World!!!
This is second line in the file.

This is third one.
```

উপরের প্রোগ্রামে তিন বার ফাইল থেকে কন্টেন্ট পড়া হয়েছে, কিন্তু তিনভাবে। প্রথমবার মাত্র একটি বাইট পড়া হয়েছে। এক বাইট মানে একটি ক্যারেক্টার। তাই সেটি প্রিন্ট করেছে শুধু `H`. এর পরে আবার পড়া হয়েছে ৪টি বাইট। তাই `ello` এই চার ক্যারেক্টার পড়া হয়েছে। যেহেতু আমরা একই ফাইল অবজেক্ট \(`file_to_work`\) নিয়ে দ্বিতীয় বারও কাজ করেছি তাই এইবার যে ৪বাইট পড়তে চেয়েছি সেটা আসলে `H` এর পর থেকে ৪বাইট। তৃতীয় বার কোন আর্গুমেন্ট ছাড়া `read` মেথড ব্যবহার করা হয়েছে এবং ফাইলের বাকী সব কন্টেন্ট পড়ে প্রিন্ট করা হয়েছে। এবারও যেহেতু একই ফাইল অবজেক্ট এর উপরেই কাজ করা হয়েছে তাই `rest_of_the_file` ভ্যারিয়েবলে কিন্তু `H`, `ello` এর পর থেকে অর্থাৎ `World ...` থেকে শেষ পর্যন্ত সব কন্টেন্ট জমা হয়েছে।

ইতোমধ্যে অনেকের মনে হতে পারে, এভাবে পুরো কন্টেন্ট একবারে পড়া এবং সেগুলো নিয়ে কাজ করা একটু ঝামেলা হবে; তাদের জন্য আছে `readlines` মেথড। এই মেথড ব্যবহার করলে ফাইলের প্রত্যেকটি লাইন আলাদা আলাদা করে নিয়ে পাইথন একটি লিস্ট বানায় এবং লিস্টের এক একটি এলিমেন্ট হয় এক একটি লাইন। নিচের উদাহরণটি দেখি -

```python
file_to_work = open("Test.txt", "r")

lines = file_to_work.readlines()
print(lines)

file_to_work.close()
```

আউটপুট,

```python
['Hello World!!!\n', 'This is second line in the file.\n', '\n', 'This is third one. \n']
```

অনেকেই হয়তো ভাবছেন লিস্ট যেহেতু পেয়ে গেছি তাহলে এবার লাইন বাই লাইন নিয়ে কাজ করার জন্য ফর লুপ ব্যবহার করে সহজেই কাজ করে ফেলবো। আপনার কথা মাথায় রেখেই পাইথনের ফর লুপ রেডি হয়েই আছে। নিচের উদাহরণটি দেখুন -

```python
file_to_work = open("Test.txt", "r")

for my_line in file_to_work:
    print(my_line)

file_to_work.close()
```

আউটপুট,

```python
Hello World!!!

This is second line in the file.



This is third one.
```

দেখুন কিভাবে আলাদা করে `read` বা `readlines` মেথড ব্যবহার না করেই সরাসরি ফর লুপ ব্যবহার করে প্রত্যেকটি লাইনকে অ্যাক্সেস করা যায়। আউটপুট স্ক্রিনে একটা করে ফাকা লাইন বেশি প্রিন্ট হয়েছে। এতে প্রমাণিত হয় যে, ফর লুপের মধ্যে থাকা প্রিন্ট স্টেটমেন্ট আলাদা আলাদা ভাবে তিনবার এক্সিকিউট হয়েছে যার কারনে প্রত্যেকবার প্রিন্টের পর একটি করে ফাকা লাইন প্রিন্ট হয়েছে।

> সংকলন - [নুহিল মেহেদী](https://nuhil.net)

